import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
from datetime import datetime
from openpyxl import load_workbook

# -------------------------------------------------------
# CONFIGURAÇÕES INICIAIS e NOMES DE ARQUIVOS
# -------------------------------------------------------
ARQUIVO_CSV = 'trades.csv'
ARQUIVO_XLSX = 'trades.xlsx'

# -------------------------------------------------------
# MÓDULO 1: Funções de Cálculo de Colunas Derivadas
# -------------------------------------------------------
def calcular_colunas_derivadas(df):
    """
    Recebe um DataFrame com as colunas mínimas:
      - 'Data' (datetime)
      - 'Ativo' (str)
      - 'Contratos' (int)
      - 'Lucro_Liquido' (float)
    Gera e retorna o DataFrame com colunas adicionais:
      - SaldoAcumulado: soma cumulativa de 'Lucro_Liquido'
      - PicoAcumulado: máximo cumulativo de 'SaldoAcumulado'
      - Drawdown: ((SaldoAcumulado - PicoAcumulado) / PicoAcumulado) * 100
      - Resultado (%): (Lucro_Liquido / SaldoAnterior) * 100
    """
    df = df.copy()

    # 1) Garante tipo correto para Lucro_Liquido
    if 'Lucro_Liquido' not in df.columns:
        df['Lucro_Liquido'] = 0.0
    df['Lucro_Liquido'] = df['Lucro_Liquido'].astype(float)

    # 2) SaldoAcumulado: soma cumulativa de Lucro_Liquido
    df['SaldoAcumulado'] = df['Lucro_Liquido'].cumsum()

    # 3) PicoAcumulado: máximo cumulativo de SaldoAcumulado
    df['PicoAcumulado'] = df['SaldoAcumulado'].cummax()

    # 4) Drawdown (%) = (SaldoAcumulado - PicoAcumulado) / PicoAcumulado * 100
    df['Drawdown'] = (
        (df['SaldoAcumulado'] - df['PicoAcumulado']) /
        df['PicoAcumulado'].replace(0, np.nan)
    ) * 100
    df['Drawdown'] = df['Drawdown'].fillna(0)

    # 5) Resultado (%) = (Lucro_Liquido / SaldoAnterior) * 100
    #    "SaldoAnterior" é "SaldoAcumulado" deslocado uma linha para baixo
    df['SaldoAnterior'] = df['SaldoAcumulado'].shift(1).fillna(0)
    # Evita divisão por zero: se SaldoAnterior == 0, define Resultado = 0
    df['Resultado (%)'] = np.where(
        df['SaldoAnterior'] != 0,
        (df['Lucro_Liquido'] / df['SaldoAnterior']) * 100,
        0.0
    )

    # Remove a coluna auxiliar 'SaldoAnterior'
    df.drop(columns=['SaldoAnterior'], inplace=True)

    return df

# -------------------------------------------------------
# MÓDULO 2: Carregar / Salvar Dados e Formatar Excel
# -------------------------------------------------------
def carregar_dados():
    """
    Lê o CSV 'trades.csv', converte 'Data' para datetime e
    recria as colunas derivadas. Se o arquivo não existir,
    retorna um DataFrame vazio com as colunas base definidas.
    """
    if os.path.exists(ARQUIVO_CSV):
        df = pd.read_csv(
            ARQUIVO_CSV,
            parse_dates=['Data'],
            dayfirst=True  # interpreta 'DD/MM/YYYY'
        )
        # Garante que 'Contratos' seja int e 'Ativo' seja string
        df['Contratos'] = df['Contratos'].astype(int)
        df['Ativo'] = df['Ativo'].astype(str)
        df['Lucro_Liquido'] = df['Lucro_Liquido'].astype(float)
    else:
        # Colunas base: Data, Ativo, Contratos, Lucro_Liquido
        df = pd.DataFrame(columns=['Data', 'Ativo', 'Contratos', 'Lucro_Liquido'])

    # Recria as colunas derivadas (SaldoAcumulado, Drawdown, Resultado)
    df = calcular_colunas_derivadas(df)
    return df

def aplicar_formatacao_excel():
    """
    Abre o arquivo Excel 'trades.xlsx' e aplica formatações:
      - 'Data'          → formato 'DD/MM/YYYY'
      - 'Ativo'         → texto normal
      - 'Contratos'     → inteiro
      - 'Lucro_Liquido' → moeda 'R$ #,##0.00'
      - 'SaldoAcumulado', 'PicoAcumulado' → moeda 'R$ #,##0.00'
      - 'Drawdown'      → porcentagem '0.00%'
      - 'Resultado (%)' → porcentagem '0.00%'
    """
    if not os.path.exists(ARQUIVO_XLSX):
        return

    wb = load_workbook(ARQUIVO_XLSX)
    ws = wb.active

    # Cria um dict {nome_coluna: índice_coluna}
    col_idx = {ws.cell(row=1, column=c).value: c for c in range(1, ws.max_column + 1)}

    # 1) Formatar 'Data'
    if 'Data' in col_idx:
        for row in range(2, ws.max_row + 1):
            ws.cell(row=row, column=col_idx['Data']).number_format = 'DD/MM/YYYY'

    # 2) Formatar monetários
    for header in ['Lucro_Liquido', 'SaldoAcumulado', 'PicoAcumulado']:
        if header in col_idx:
            for row in range(2, ws.max_row + 1):
                ws.cell(row=row, column=col_idx[header]).number_format = 'R$ #,##0.00'

    # 3) Formatar 'Drawdown' e 'Resultado (%)' como porcentagem
    for header in ['Drawdown', 'Resultado (%)']:
        if header in col_idx:
            for row in range(2, ws.max_row + 1):
                ws.cell(row=row, column=col_idx[header]).number_format = '0.00%'

    wb.save(ARQUIVO_XLSX)

def salvar_dados(df):
    """
    Recebe um DataFrame (já contendo as colunas base + derivadas)
    e salva em CSV e XLSX, aplicando a formatação no Excel.
    """
    df_to_save = df.copy()
    # Recria as colunas derivadas (caso tenham sido alteradas)
    df_to_save = calcular_colunas_derivadas(df_to_save)

    # 1) Salva em CSV
    df_to_save.to_csv(ARQUIVO_CSV, index=False)
    # 2) Salva em XLSX
    df_to_save.to_excel(ARQUIVO_XLSX, index=False)
    # 3) Aplica formatação no XLSX
    aplicar_formatacao_excel()

# -------------------------------------------------------
# MÓDULO 3: Funções de Inserção de Trades
# -------------------------------------------------------
def adicionar_trade(df, data_input, ativo, contratos, lucro):
    """
    Adiciona um trade ao DataFrame. Parâmetros:
      - df          : DataFrame carregado por carregar_dados()
      - data_input  : string no formato 'DD/MM' ou 'DD/MM/AAAA'
      - ativo       : string ('WDO' ou 'WIN')
      - contratos   : int (nº de contratos da operação)
      - lucro       : float (lucro líquido, já com taxas descontadas)

    Retorna o DataFrame recarregado com colunas derivadas atualizadas.
    """
    # 1) Converte data_input para datetime
    try:
        if len(data_input.split('/')) == 2:
            # 'DD/MM' → acrescenta ano atual
            ano_atual = datetime.now().year
            data_str = f"{data_input}/{ano_atual}"
            data_dt = datetime.strptime(data_str, "%d/%m/%Y")
        else:
            # 'DD/MM/AAAA'
            data_dt = datetime.strptime(data_input, "%d/%m/%Y")
    except ValueError:
        st.error("Data inválida. Use DD/MM ou DD/MM/AAAA.")
        return df

    # 2) Cria um DataFrame temporário para o novo trade
    novo_trade_df = pd.DataFrame([{
        'Data': data_dt,
        'Ativo': ativo,
        'Contratos': int(contratos),
        'Lucro_Liquido': float(lucro)
    }])

    # 3) Extrai apenas colunas base de 'df' (caso existam)
    #    Isso evita warnings de concatenação com colunas derivadas
    if set(['Data', 'Ativo', 'Contratos', 'Lucro_Liquido']).issubset(df.columns):
        base_df = df[['Data', 'Ativo', 'Contratos', 'Lucro_Liquido']].copy()
    else:
        base_df = pd.DataFrame(columns=['Data', 'Ativo', 'Contratos', 'Lucro_Liquido'])

    # 4) Concatena o base_df com o novo_trade_df
    base_df = pd.concat([base_df, novo_trade_df], ignore_index=True)

    # 5) Salva em disco (CSV + XLSX) e recarrega colunas derivadas
    salvar_dados(base_df)
    return carregar_dados()


# -------------------------------------------------------
# MÓDULO 4: Funções Estatísticas
# -------------------------------------------------------
def calcular_indicadores(df):
    """
    Retorna um dict com os principais indicadores de performance:
      - Total de Trades
      - Taxa de Acerto (%)
      - Retorno Médio (R$)
      - Expectância (R$)
      - Profit Factor
      - Sharpe Ratio
      - Sortino Ratio

    Se não houver dados, retorna None.
    """
    if df.empty:
        return None

    lucros = df['Lucro_Liquido']
    ganhos = lucros[lucros > 0]
    perdas = lucros[lucros < 0]

    total = len(lucros)
    acertos = len(ganhos)
    erros = len(perdas)

    ret_med = lucros.mean()
    std = lucros.std() if total > 1 else 0

    expect = (
        ganhos.mean() * (acertos / total) +
        perdas.mean() * (erros / total)
    ) if total else 0

    pf = ganhos.sum() / abs(perdas.sum()) if abs(perdas.sum()) > 0 else np.nan
    sharpe = ret_med / std if std > 0 else np.nan
    sortino = ret_med / perdas.std() if perdas.std() > 0 else np.nan
    taxa = (acertos / total) * 100 if total else 0

    return {
        "Total Trades": total,
        "Taxa de Acerto (%)": taxa,
        "Retorno Médio (R$)": ret_med,
        "Expectância (R$)": expect,
        "Profit Factor": pf,
        "Sharpe Ratio": sharpe,
        "Sortino Ratio": sortino
    }
