import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
from datetime import datetime
from openpyxl import load_workbook

# -------------------------------------------------------
# CONFIGURA√á√ïES INICIAIS e NOMES DE ARQUIVOS
# -------------------------------------------------------
ARQUIVO_CSV = 'trades.csv'
ARQUIVO_XLSX = 'trades.xlsx'

# -------------------------------------------------------
# M√ìDULO 1: Fun√ß√µes de C√°lculo de Colunas Derivadas
# -------------------------------------------------------
def calcular_colunas_derivadas(df):
    """
    Recebe um DataFrame com as colunas m√≠nimas:
      - 'Data' (datetime)
      - 'Ativo' (str)
      - 'Contratos' (int)
      - 'Lucro_Liquido' (float)
    Gera e retorna o DataFrame com colunas adicionais:
      - SaldoAcumulado: soma cumulativa de 'Lucro_Liquido'
      - PicoAcumulado: m√°ximo cumulativo de 'SaldoAcumulado'
      - Drawdown: ((SaldoAcumulado - PicoAcumulado) / PicoAcumulado) * 100
      - Resultado (%): (Lucro_Liquido / SaldoAnterior) * 100
    """
    df = df.copy()

    # 1) Garante tipo correto para Lucro_Liquido
    if 'Lucro_Liquido' not in df.columns:
        df['Lucro_Liquido'] = 0.0
    df['Lucro_Liquido'] = df['Lucro_Liquido'].astype(float)

    # 2) SaldoAcumulado: soma cumulativa de Lucro_Liquido
    df['SaldoAcumulado'] = df['Lucro_Liquido'].cumsum()

    # 3) PicoAcumulado: m√°ximo cumulativo de SaldoAcumulado
    df['PicoAcumulado'] = df['SaldoAcumulado'].cummax()

    # 4) Drawdown (%) = (SaldoAcumulado - PicoAcumulado) / PicoAcumulado * 100
    df['Drawdown'] = (
        (df['SaldoAcumulado'] - df['PicoAcumulado']) /
        df['PicoAcumulado'].replace(0, np.nan)
    ) * 100
    df['Drawdown'] = df['Drawdown'].fillna(0)

    # 5) Resultado (%) = (Lucro_Liquido / SaldoAnterior) * 100
    #    "SaldoAnterior" √© "SaldoAcumulado" deslocado uma linha para baixo
    df['SaldoAnterior'] = df['SaldoAcumulado'].shift(1).fillna(0)
    # Evita divis√£o por zero: se SaldoAnterior == 0, define Resultado = 0
    df['Resultado (%)'] = np.where(
        df['SaldoAnterior'] != 0,
        (df['Lucro_Liquido'] / df['SaldoAnterior']) * 100,
        0.0
    )

    # Remove a coluna auxiliar 'SaldoAnterior'
    df.drop(columns=['SaldoAnterior'], inplace=True)

    return df

# -------------------------------------------------------
# M√ìDULO 2: Carregar / Salvar Dados e Formatar Excel
# -------------------------------------------------------
def carregar_dados():
    """
    L√™ o CSV 'trades.csv', converte 'Data' para datetime e
    recria as colunas derivadas. Se o arquivo n√£o existir,
    retorna um DataFrame vazio com as colunas base definidas.
    """
    if os.path.exists(ARQUIVO_CSV):
        df = pd.read_csv(
            ARQUIVO_CSV,
            parse_dates=['Data'],
            dayfirst=True  # interpreta 'DD/MM/YYYY'
        )
        # Garante que 'Contratos' seja int e 'Ativo' seja string
        df['Contratos'] = df['Contratos'].astype(int)
        df['Ativo'] = df['Ativo'].astype(str)
        df['Lucro_Liquido'] = df['Lucro_Liquido'].astype(float)
    else:
        # Colunas base: Data, Ativo, Contratos, Lucro_Liquido
        df = pd.DataFrame(columns=['Data', 'Ativo', 'Contratos', 'Lucro_Liquido'])

    # Recria as colunas derivadas (SaldoAcumulado, Drawdown, Resultado)
    df = calcular_colunas_derivadas(df)
    return df

def aplicar_formatacao_excel():
    """
    Abre o arquivo Excel 'trades.xlsx' e aplica formata√ß√µes:
      - 'Data'          ‚Üí formato 'DD/MM/YYYY'
      - 'Ativo'         ‚Üí texto normal
      - 'Contratos'     ‚Üí inteiro
      - 'Lucro_Liquido' ‚Üí moeda 'R$ #,##0.00'
      - 'SaldoAcumulado', 'PicoAcumulado' ‚Üí moeda 'R$ #,##0.00'
      - 'Drawdown'      ‚Üí porcentagem '0.00%'
      - 'Resultado (%)' ‚Üí porcentagem '0.00%'
    """
    if not os.path.exists(ARQUIVO_XLSX):
        return

    wb = load_workbook(ARQUIVO_XLSX)
    ws = wb.active

    # Cria um dict {nome_coluna: √≠ndice_coluna}
    col_idx = {ws.cell(row=1, column=c).value: c for c in range(1, ws.max_column + 1)}

    # 1) Formatar 'Data'
    if 'Data' in col_idx:
        for row in range(2, ws.max_row + 1):
            ws.cell(row=row, column=col_idx['Data']).number_format = 'DD/MM/YYYY'

    # 2) Formatar monet√°rios
    for header in ['Lucro_Liquido', 'SaldoAcumulado', 'PicoAcumulado']:
        if header in col_idx:
            for row in range(2, ws.max_row + 1):
                ws.cell(row=row, column=col_idx[header]).number_format = 'R$ #,##0.00'

    # 3) Formatar 'Drawdown' e 'Resultado (%)' como porcentagem
    for header in ['Drawdown', 'Resultado (%)']:
        if header in col_idx:
            for row in range(2, ws.max_row + 1):
                ws.cell(row=row, column=col_idx[header]).number_format = '0.00%'

    wb.save(ARQUIVO_XLSX)

def salvar_dados(df):
    """
    Recebe um DataFrame (j√° contendo as colunas base + derivadas)
    e salva em CSV e XLSX, aplicando a formata√ß√£o no Excel.
    """
    df_to_save = df.copy()
    # Recria as colunas derivadas (caso tenham sido alteradas)
    df_to_save = calcular_colunas_derivadas(df_to_save)

    # 1) Salva em CSV
    df_to_save.to_csv(ARQUIVO_CSV, index=False)
    # 2) Salva em XLSX
    df_to_save.to_excel(ARQUIVO_XLSX, index=False)
    # 3) Aplica formata√ß√£o no XLSX
    aplicar_formatacao_excel()

# -------------------------------------------------------
# M√ìDULO 3: Fun√ß√µes de Inser√ß√£o de Trades
# -------------------------------------------------------
def adicionar_trade(df, data_input, ativo, contratos, lucro):
    """
    Adiciona um trade ao DataFrame. Par√¢metros:
      - df          : DataFrame carregado por carregar_dados()
      - data_input  : string no formato 'DD/MM' ou 'DD/MM/AAAA'
      - ativo       : string ('WDO' ou 'WIN')
      - contratos   : int (n¬∫ de contratos da opera√ß√£o)
      - lucro       : float (lucro l√≠quido, j√° com taxas descontadas)

    Retorna o DataFrame recarregado com colunas derivadas atualizadas.
    """
    # 1) Converte data_input para datetime
    try:
        if len(data_input.split('/')) == 2:
            # 'DD/MM' ‚Üí acrescenta ano atual
            ano_atual = datetime.now().year
            data_str = f"{data_input}/{ano_atual}"
            data_dt = datetime.strptime(data_str, "%d/%m/%Y")
        else:
            # 'DD/MM/AAAA'
            data_dt = datetime.strptime(data_input, "%d/%m/%Y")
    except ValueError:
        st.error("Data inv√°lida. Use DD/MM ou DD/MM/AAAA.")
        return df

    # 2) Cria um DataFrame tempor√°rio para o novo trade
    novo_trade_df = pd.DataFrame([{
        'Data': data_dt,
        'Ativo': ativo,
        'Contratos': int(contratos),
        'Lucro_Liquido': float(lucro)
    }])

    # 3) Extrai apenas colunas base de 'df' (caso existam)
    #    Isso evita warnings de concatena√ß√£o com colunas derivadas
    if set(['Data', 'Ativo', 'Contratos', 'Lucro_Liquido']).issubset(df.columns):
        base_df = df[['Data', 'Ativo', 'Contratos', 'Lucro_Liquido']].copy()
    else:
        base_df = pd.DataFrame(columns=['Data', 'Ativo', 'Contratos', 'Lucro_Liquido'])

    # 4) Concatena o base_df com o novo_trade_df
    base_df = pd.concat([base_df, novo_trade_df], ignore_index=True)

    # 5) Salva em disco (CSV + XLSX) e recarrega colunas derivadas
    salvar_dados(base_df)
    return carregar_dados()


# -------------------------------------------------------
# M√ìDULO 4: Fun√ß√µes Estat√≠sticas
# -------------------------------------------------------
def calcular_indicadores(df):
    """
    Retorna um dict com os principais indicadores de performance:
      - Total de Trades
      - Taxa de Acerto (%)
      - Retorno M√©dio (R$)
      - Expect√¢ncia (R$)
      - Profit Factor
      - Sharpe Ratio
      - Sortino Ratio

    Se n√£o houver dados, retorna None.
    """
    if df.empty:
        return None

    lucros = df['Lucro_Liquido']
    ganhos = lucros[lucros > 0]
    perdas = lucros[lucros < 0]

    total = len(lucros)
    acertos = len(ganhos)
    erros = len(perdas)

    ret_med = lucros.mean()
    std = lucros.std() if total > 1 else 0

    expect = (
        ganhos.mean() * (acertos / total) +
        perdas.mean() * (erros / total)
    ) if total else 0

    pf = ganhos.sum() / abs(perdas.sum()) if abs(perdas.sum()) > 0 else np.nan
    sharpe = ret_med / std if std > 0 else np.nan
    sortino = ret_med / perdas.std() if perdas.std() > 0 else np.nan
    taxa = (acertos / total) * 100 if total else 0

    return {
        "Total Trades": total,
        "Taxa de Acerto (%)": taxa,
        "Retorno M√©dio (R$)": ret_med,
        "Expect√¢ncia (R$)": expect,
        "Profit Factor": pf,
        "Sharpe Ratio": sharpe,
        "Sortino Ratio": sortino
    }


# -------------------------------------------------------
# M√ìDULO 5: Fun√ß√µes de Plotagem
# -------------------------------------------------------
def plot_curva_patrimonio(df):
    """
    Plota a curva de patrim√¥nio (SaldoAcumulado) com:
      - Linha de breakeven (y=0)
      - Anota√ß√£o do drawdown m√°ximo
    """
    if df.empty:
        st.warning("N√£o h√° dados para plotar curva de patrim√¥nio.")
        return

    fig, ax = plt.subplots(figsize=(10, 5))
    ax.plot(df["SaldoAcumulado"], label="Saldo Acumulado")
    ax.axhline(0, color='gray', linestyle='--', label='Breakeven')

    # Anota o drawdown m√°ximo
    max_dd = df["Drawdown"].min()
    idx_max_dd = df["Drawdown"].idxmin()
    ax.annotate(
        f"Max Drawdown: {max_dd:.2f}%",
        xy=(idx_max_dd, df.loc[idx_max_dd, "SaldoAcumulado"]),
        xytext=(idx_max_dd, df["SaldoAcumulado"].max() * 0.5),
        arrowprops=dict(facecolor='red', shrink=0.05)
    )

    ax.set_title("Curva de Patrim√¥nio ao Longo dos Trades")
    ax.set_xlabel("√çndice de Trade")
    ax.set_ylabel("R$")
    ax.legend()
    ax.grid(True)
    st.pyplot(fig)

def plot_drawdown(df):
    """
    Plota a evolu√ß√£o de Drawdown (%) ao longo dos trades.
    """
    if df.empty:
        st.warning("N√£o h√° dados para plotar drawdown.")
        return

    fig, ax = plt.subplots(figsize=(10, 5))
    ax.plot(df["Drawdown"], label="Drawdown (%)", color='red')
    ax.set_title("Drawdown (%) ao Longo dos Trades")
    ax.set_xlabel("√çndice de Trade")
    ax.set_ylabel("Drawdown (%)")
    ax.legend()
    ax.grid(True)
    st.pyplot(fig)

def plot_histograma(df):
    """
    Plota histograma dos valores de Lucro_Liquido (ou ProfitLoss).
    """
    if df.empty:
        st.warning("N√£o h√° dados para plotar histograma.")
        return

    fig, ax = plt.subplots(figsize=(10, 5))
    ax.hist(df["Lucro_Liquido"], bins=10, edgecolor='black')
    ax.set_title("Histograma de Retornos por Trade (P/L)")
    ax.set_xlabel("P/L (R$)")
    ax.set_ylabel("Frequ√™ncia")
    ax.grid(True)
    st.pyplot(fig)


# -------------------------------------------------------
# M√ìDULO 6: Layout Principal do Streamlit
# -------------------------------------------------------
st.set_page_config(page_title="Painel de Controle de Trades", layout="wide")
st.title("üìä Painel de Acompanhamento de Trades")

# 1) Carrega o DataFrame (com colunas derivadas)
df = carregar_dados()

# -------------------------------------------------------
# SECTION: Sidebar para Inser√ß√£o de Novo Trade
# -------------------------------------------------------
st.sidebar.header("‚ûï Adicionar Trade (Novo)")

# 1.1) Campo de Data (DD/MM ou DD/MM/AAAA)
data_input = st.sidebar.text_input("Data (DD/MM ou DD/MM/AAAA)", "")

# 1.2) Campo Ativo (lista suspensa)
ativo_input = st.sidebar.selectbox("Ativo", ["WDO", "WIN"])

# 1.3) Campo Quantidade de Contratos
contratos_input = st.sidebar.number_input("Contratos", min_value=1, step=1, value=1)

# 1.4) Campo Lucro L√≠quido (j√° liquido de taxas)
lucro_input = st.sidebar.text_input("Lucro L√≠quido (ex: 62.70)", "")

# 1.5) Bot√£o para adicionar
if st.sidebar.button("‚ûï Registrar Trade"):
    # Verifica se todos os campos foram preenchidos
    if data_input.strip() and ativo_input and lucro_input.strip():
        try:
            # Converte lucro para float (aceita v√≠rgula ou ponto)
            lucro_val = float(lucro_input.replace(",", "."))
            # Chama a fun√ß√£o que adiciona o trade
            df = adicionar_trade(df, data_input, ativo_input, contratos_input, lucro_val)
            st.sidebar.success("‚úÖ Trade adicionado com sucesso!")
        except ValueError:
            st.sidebar.error("‚ùå Valor inv√°lido para Lucro L√≠quido.")
    else:
        st.sidebar.warning("Preencha todos os campos: Data, Ativo e Lucro.")


# -------------------------------------------------------
# SECTION: Sidebar de Indicadores com Explica√ß√£o
# -------------------------------------------------------
with st.sidebar.expander("üìà Indicadores", expanded=False):
    indicadores = calcular_indicadores(df)
    if indicadores:
        for nome, valor in indicadores.items():
            if isinstance(valor, (int, float, np.floating)):
                st.metric(label=nome, value=f"{valor:,.2f}")
            else:
                st.metric(label=nome, value=str(valor))
        st.markdown("**‚ÑπÔ∏è Faixas de Desempenho de Indicadores**")
        st.markdown("""
- **Taxa de Acerto** (Percentual de trades vencedores)      
  - üî¥ Cr√≠tico: < 40%  
  - üü† Ruim: 40% ‚Äì 49%  
  - üü° Moderado: 50% ‚Äì 59%  
  - üü¢ Bom: 60% ‚Äì 69%  
  - üîµ Excelente: ‚â• 70%

- **Retorno M√©dio (R$)** (Ganho ou perda m√©dia por trade)  
  - üî¥ Negativo: < 0  
  - üü° Leve: 0 ‚Äì 1  
  - üü¢ S√≥lido: 1 ‚Äì 2  
  - üîµ Excelente: > 2

- **Expect√¢ncia (R$)** (Lucro ou preju√≠zo esperado por opera√ß√£o)  
  - üî¥ Negativa: < 0  
  - üü° Neutra: 0 ‚Äì 0.5  
  - üü¢ Positiva: 0.5 ‚Äì 1  
  - üîµ Excelente: > 1

- **Profit Factor** (Raz√£o entre o total ganho e o total perdido)  
  - üî¥ Cr√≠tico: < 1  
  - üü° Fraco: 1 ‚Äì 1.5  
  - üü¢ Bom: 1.5 ‚Äì 2  
  - üîµ Excelente: > 2

- **Sharpe Ratio** (Avalia se o retorno compensa o risco)  
  - üî¥ Inaceit√°vel: < 0.5  
  - üü° Fraco: 0.5 ‚Äì 1  
  - üü¢ Bom: 1 ‚Äì 2  
  - üîµ Excelente: > 2

- **Sortino Ratio** (penaliza s√≥ a volatilidade negativa)  
  - üî¥ Fraco: < 1  
  - üü° M√©dio: 1 ‚Äì 1.5  
  - üü¢ Bom: 1.5 ‚Äì 2  
  - üîµ Excelente: > 2
        """)
    else:
        st.write("Sem dados para mostrar indicadores.")

